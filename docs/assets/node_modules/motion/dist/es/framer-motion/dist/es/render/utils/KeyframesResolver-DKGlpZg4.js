import{removeNonTranslationalTransform as y}from"../dom/utils/unit-conversion-LQjkVvbB.js";import{frame as m}from"../../frameloop/frame-DhSIuZ3-.js";const i=new Set;let d=!1,u=!1;function h(){if(u){const n=Array.from(i).filter(e=>e.needsMeasurement),s=new Set(n.map(e=>e.element)),a=new Map;s.forEach(e=>{const t=y(e);t.length&&(a.set(e,t),e.render())}),n.forEach(e=>e.measureInitialState()),s.forEach(e=>{e.render();const t=a.get(e);t&&t.forEach(([r,l])=>{var f;(f=e.getValue(r))===null||f===void 0||f.set(l)})}),n.forEach(e=>e.measureEndState()),n.forEach(e=>{e.suspendedScrollY!==void 0&&window.scrollTo(0,e.suspendedScrollY)})}u=!1,d=!1,i.forEach(n=>n.complete()),i.clear()}function c(){i.forEach(n=>{n.readKeyframes(),n.needsMeasurement&&(u=!0)})}function S(){c(),h()}class v{constructor(s,a,e,t,r,l=!1){this.isComplete=!1,this.isAsync=!1,this.needsMeasurement=!1,this.isScheduled=!1,this.unresolvedKeyframes=[...s],this.onComplete=a,this.name=e,this.motionValue=t,this.element=r,this.isAsync=l}scheduleResolve(){this.isScheduled=!0,this.isAsync?(i.add(this),d||(d=!0,m.read(c),m.resolveKeyframes(h))):(this.readKeyframes(),this.complete())}readKeyframes(){const{unresolvedKeyframes:s,name:a,element:e,motionValue:t}=this;for(let r=0;r<s.length;r++)if(s[r]===null)if(r===0){const l=t==null?void 0:t.get(),f=s[s.length-1];if(l!==void 0)s[0]=l;else if(e&&a){const o=e.readValue(a,f);o!=null&&(s[0]=o)}s[0]===void 0&&(s[0]=f),t&&l===void 0&&t.set(s[0])}else s[r]=s[r-1]}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(){this.isComplete=!0,this.onComplete(this.unresolvedKeyframes,this.finalKeyframe),i.delete(this)}cancel(){this.isComplete||(this.isScheduled=!1,i.delete(this))}resume(){this.isComplete||this.scheduleResolve()}}export{v as KeyframeResolver,S as flushKeyframeResolvers};
