import _ from"../../delaunator/index-CfVLg6Lq.js";import w from"./path-BBlkaCM4.js";import m from"./polygon-CpMFK2ih.js";import I from"./voronoi-BrP_fx1T.js";const T=2*Math.PI,p=Math.pow;function b(u){return u[0]}function P(u){return u[1]}function A(u){const{triangles:e,coords:n}=u;for(let l=0;l<e.length;l+=3){const t=2*e[l],r=2*e[l+1],s=2*e[l+2];if((n[s]-n[t])*(n[r+1]-n[t+1])-(n[r]-n[t])*(n[s+1]-n[t+1])>1e-10)return!1}return!0}function M(u,e,n){return[u+Math.sin(u+e)*n,e+Math.cos(u-e)*n]}class v{static from(e,n=b,l=P,t){return new v("length"in e?H(e,n,l,t):Float64Array.from(j(e,n,l,t)))}constructor(e){this._delaunator=new _(e),this.inedges=new Int32Array(e.length/2),this._hullIndex=new Int32Array(e.length/2),this.points=this._delaunator.coords,this._init()}update(){return this._delaunator.update(),this._init(),this}_init(){const e=this._delaunator,n=this.points;if(e.hull&&e.hull.length>2&&A(e)){this.collinear=Int32Array.from({length:n.length/2},(g,a)=>a).sort((g,a)=>n[2*g]-n[2*a]||n[2*g+1]-n[2*a+1]);const i=this.collinear[0],o=this.collinear[this.collinear.length-1],f=[n[2*i],n[2*i+1],n[2*o],n[2*o+1]],d=1e-8*Math.hypot(f[3]-f[1],f[2]-f[0]);for(let g=0,a=n.length/2;g<a;++g){const c=M(n[2*g],n[2*g+1],d);n[2*g]=c[0],n[2*g+1]=c[1]}this._delaunator=new _(n)}else delete this.collinear;const l=this.halfedges=this._delaunator.halfedges,t=this.hull=this._delaunator.hull,r=this.triangles=this._delaunator.triangles,s=this.inedges.fill(-1),h=this._hullIndex.fill(-1);for(let i=0,o=l.length;i<o;++i){const f=r[i%3===2?i-2:i+1];(l[i]===-1||s[f]===-1)&&(s[f]=i)}for(let i=0,o=t.length;i<o;++i)h[t[i]]=i;t.length<=2&&t.length>0&&(this.triangles=new Int32Array(3).fill(-1),this.halfedges=new Int32Array(3).fill(-1),this.triangles[0]=t[0],s[t[0]]=1,t.length===2&&(s[t[1]]=0,this.triangles[1]=t[1],this.triangles[2]=t[1]))}voronoi(e){return new I(this,e)}*neighbors(e){const{inedges:n,hull:l,_hullIndex:t,halfedges:r,triangles:s,collinear:h}=this;if(h){const d=h.indexOf(e);d>0&&(yield h[d-1]),d<h.length-1&&(yield h[d+1]);return}const i=n[e];if(i===-1)return;let o=i,f=-1;do{if(yield f=s[o],o=o%3===2?o-2:o+1,s[o]!==e)return;if(o=r[o],o===-1){const d=l[(t[e]+1)%l.length];d!==f&&(yield d);return}}while(o!==i)}find(e,n,l=0){if(e=+e,e!==e||(n=+n,n!==n))return-1;const t=l;let r;for(;(r=this._step(l,e,n))>=0&&r!==l&&r!==t;)l=r;return r}_step(e,n,l){const{inedges:t,hull:r,_hullIndex:s,halfedges:h,triangles:i,points:o}=this;if(t[e]===-1||!o.length)return(e+1)%(o.length>>1);let f=e,d=p(n-o[e*2],2)+p(l-o[e*2+1],2);const g=t[e];let a=g;do{let c=i[a];const y=p(n-o[c*2],2)+p(l-o[c*2+1],2);if(y<d&&(d=y,f=c),a=a%3===2?a-2:a+1,i[a]!==e)break;if(a=h[a],a===-1){if(a=r[(s[e]+1)%r.length],a!==c&&p(n-o[a*2],2)+p(l-o[a*2+1],2)<d)return a;break}}while(a!==g);return f}render(e){const n=e==null?e=new w:void 0,{points:l,halfedges:t,triangles:r}=this;for(let s=0,h=t.length;s<h;++s){const i=t[s];if(i<s)continue;const o=r[s]*2,f=r[i]*2;e.moveTo(l[o],l[o+1]),e.lineTo(l[f],l[f+1])}return this.renderHull(e),n&&n.value()}renderPoints(e,n){n===void 0&&(!e||typeof e.moveTo!="function")&&(n=e,e=null),n=n==null?2:+n;const l=e==null?e=new w:void 0,{points:t}=this;for(let r=0,s=t.length;r<s;r+=2){const h=t[r],i=t[r+1];e.moveTo(h+n,i),e.arc(h,i,n,0,T)}return l&&l.value()}renderHull(e){const n=e==null?e=new w:void 0,{hull:l,points:t}=this,r=l[0]*2,s=l.length;e.moveTo(t[r],t[r+1]);for(let h=1;h<s;++h){const i=2*l[h];e.lineTo(t[i],t[i+1])}return e.closePath(),n&&n.value()}hullPolygon(){const e=new m;return this.renderHull(e),e.value()}renderTriangle(e,n){const l=n==null?n=new w:void 0,{points:t,triangles:r}=this,s=r[e*=3]*2,h=r[e+1]*2,i=r[e+2]*2;return n.moveTo(t[s],t[s+1]),n.lineTo(t[h],t[h+1]),n.lineTo(t[i],t[i+1]),n.closePath(),l&&l.value()}*trianglePolygons(){const{triangles:e}=this;for(let n=0,l=e.length/3;n<l;++n)yield this.trianglePolygon(n)}trianglePolygon(e){const n=new m;return this.renderTriangle(e,n),n.value()}}function H(u,e,n,l){const t=u.length,r=new Float64Array(t*2);for(let s=0;s<t;++s){const h=u[s];r[s*2]=e.call(l,h,s,u),r[s*2+1]=n.call(l,h,s,u)}return r}function*j(u,e,n,l){let t=0;for(const r of u)yield e.call(l,r,t,u),yield n.call(l,r,t,u),++t}export{v as default};
