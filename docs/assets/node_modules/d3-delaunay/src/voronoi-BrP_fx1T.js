import F from"./path-BBlkaCM4.js";import D from"./polygon-CpMFK2ih.js";class K{constructor(i,[t,n,e,s]=[0,0,960,500]){if(!((e=+e)>=(t=+t))||!((s=+s)>=(n=+n)))throw new Error("invalid bounds");this.delaunay=i,this._circumcenters=new Float64Array(i.points.length*2),this.vectors=new Float64Array(i.points.length*2),this.xmax=e,this.xmin=t,this.ymax=s,this.ymin=n,this._init()}update(){return this.delaunay.update(),this._init(),this}_init(){const{delaunay:{points:i,hull:t,triangles:n},vectors:e}=this;let s,l;const h=this.circumcenters=this._circumcenters.subarray(0,n.length/3*2);for(let m=0,d=0,_=n.length,b,T;m<_;m+=3,d+=2){const v=n[m]*2,A=n[m+1]*2,I=n[m+2]*2,y=i[v],w=i[v+1],q=i[A],z=i[A+1],C=i[I],V=i[I+1],k=q-y,M=z-w,p=C-y,x=V-w,B=(k*x-M*p)*2;if(Math.abs(B)<1e-9){if(s===void 0){s=l=0;for(const S of t)s+=i[S*2],l+=i[S*2+1];s/=t.length,l/=t.length}const j=1e9*Math.sign((s-y)*x-(l-w)*p);b=(y+C)/2-j*x,T=(w+V)/2+j*p}else{const j=1/B,S=k*k+M*M,E=p*p+x*x;b=y+(x*S-M*E)*j,T=w+(k*E-p*S)*j}h[d]=b,h[d+1]=T}let r=t[t.length-1],o,c=r*4,a,f=i[2*r],g,u=i[2*r+1];e.fill(0);for(let m=0;m<t.length;++m)r=t[m],o=c,a=f,g=u,c=r*4,f=i[2*r],u=i[2*r+1],e[o+2]=e[c]=g-u,e[o+3]=e[c+1]=f-a}render(i){const t=i==null?i=new F:void 0,{delaunay:{halfedges:n,inedges:e,hull:s},circumcenters:l,vectors:h}=this;if(s.length<=1)return null;for(let c=0,a=n.length;c<a;++c){const f=n[c];if(f<c)continue;const g=Math.floor(c/3)*2,u=Math.floor(f/3)*2,m=l[g],d=l[g+1],_=l[u],b=l[u+1];this._renderSegment(m,d,_,b,i)}let r,o=s[s.length-1];for(let c=0;c<s.length;++c){r=o,o=s[c];const a=Math.floor(e[o]/3)*2,f=l[a],g=l[a+1],u=r*4,m=this._project(f,g,h[u+2],h[u+3]);m&&this._renderSegment(f,g,m[0],m[1],i)}return t&&t.value()}renderBounds(i){const t=i==null?i=new F:void 0;return i.rect(this.xmin,this.ymin,this.xmax-this.xmin,this.ymax-this.ymin),t&&t.value()}renderCell(i,t){const n=t==null?t=new F:void 0,e=this._clip(i);if(e===null||!e.length)return;t.moveTo(e[0],e[1]);let s=e.length;for(;e[0]===e[s-2]&&e[1]===e[s-1]&&s>1;)s-=2;for(let l=2;l<s;l+=2)(e[l]!==e[l-2]||e[l+1]!==e[l-1])&&t.lineTo(e[l],e[l+1]);return t.closePath(),n&&n.value()}*cellPolygons(){const{delaunay:{points:i}}=this;for(let t=0,n=i.length/2;t<n;++t){const e=this.cellPolygon(t);e&&(e.index=t,yield e)}}cellPolygon(i){const t=new D;return this.renderCell(i,t),t.value()}_renderSegment(i,t,n,e,s){let l;const h=this._regioncode(i,t),r=this._regioncode(n,e);h===0&&r===0?(s.moveTo(i,t),s.lineTo(n,e)):(l=this._clipSegment(i,t,n,e,h,r))&&(s.moveTo(l[0],l[1]),s.lineTo(l[2],l[3]))}contains(i,t,n){return t=+t,t!==t||(n=+n,n!==n)?!1:this.delaunay._step(i,t,n)===i}*neighbors(i){const t=this._clip(i);if(t)for(const n of this.delaunay.neighbors(i)){const e=this._clip(n);if(e){t:for(let s=0,l=t.length;s<l;s+=2)for(let h=0,r=e.length;h<r;h+=2)if(t[s]===e[h]&&t[s+1]===e[h+1]&&t[(s+2)%l]===e[(h+r-2)%r]&&t[(s+3)%l]===e[(h+r-1)%r]){yield n;break t}}}}_cell(i){const{circumcenters:t,delaunay:{inedges:n,halfedges:e,triangles:s}}=this,l=n[i];if(l===-1)return null;const h=[];let r=l;do{const o=Math.floor(r/3);if(h.push(t[o*2],t[o*2+1]),r=r%3===2?r-2:r+1,s[r]!==i)break;r=e[r]}while(r!==l&&r!==-1);return h}_clip(i){if(i===0&&this.delaunay.hull.length===1)return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];const t=this._cell(i);if(t===null)return null;const{vectors:n}=this,e=i*4;return this._simplify(n[e]||n[e+1]?this._clipInfinite(i,t,n[e],n[e+1],n[e+2],n[e+3]):this._clipFinite(i,t))}_clipFinite(i,t){const n=t.length;let e=null,s,l,h=t[n-2],r=t[n-1],o,c=this._regioncode(h,r),a,f=0;for(let g=0;g<n;g+=2)if(s=h,l=r,h=t[g],r=t[g+1],o=c,c=this._regioncode(h,r),o===0&&c===0)a=f,f=0,e?e.push(h,r):e=[h,r];else{let u,m,d,_,b;if(o===0){if((u=this._clipSegment(s,l,h,r,o,c))===null)continue;[m,d,_,b]=u}else{if((u=this._clipSegment(h,r,s,l,c,o))===null)continue;[_,b,m,d]=u,a=f,f=this._edgecode(m,d),a&&f&&this._edge(i,a,f,e,e.length),e?e.push(m,d):e=[m,d]}a=f,f=this._edgecode(_,b),a&&f&&this._edge(i,a,f,e,e.length),e?e.push(_,b):e=[_,b]}if(e)a=f,f=this._edgecode(e[0],e[1]),a&&f&&this._edge(i,a,f,e,e.length);else if(this.contains(i,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2))return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];return e}_clipSegment(i,t,n,e,s,l){const h=s<l;for(h&&([i,t,n,e,s,l]=[n,e,i,t,l,s]);;){if(s===0&&l===0)return h?[n,e,i,t]:[i,t,n,e];if(s&l)return null;let r,o,c=s||l;c&8?(r=i+(n-i)*(this.ymax-t)/(e-t),o=this.ymax):c&4?(r=i+(n-i)*(this.ymin-t)/(e-t),o=this.ymin):c&2?(o=t+(e-t)*(this.xmax-i)/(n-i),r=this.xmax):(o=t+(e-t)*(this.xmin-i)/(n-i),r=this.xmin),s?(i=r,t=o,s=this._regioncode(i,t)):(n=r,e=o,l=this._regioncode(n,e))}}_clipInfinite(i,t,n,e,s,l){let h=Array.from(t),r;if((r=this._project(h[0],h[1],n,e))&&h.unshift(r[0],r[1]),(r=this._project(h[h.length-2],h[h.length-1],s,l))&&h.push(r[0],r[1]),h=this._clipFinite(i,h))for(let o=0,c=h.length,a,f=this._edgecode(h[c-2],h[c-1]);o<c;o+=2)a=f,f=this._edgecode(h[o],h[o+1]),a&&f&&(o=this._edge(i,a,f,h,o),c=h.length);else this.contains(i,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2)&&(h=[this.xmin,this.ymin,this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax]);return h}_edge(i,t,n,e,s){for(;t!==n;){let l,h;switch(t){case 5:t=4;continue;case 4:t=6,l=this.xmax,h=this.ymin;break;case 6:t=2;continue;case 2:t=10,l=this.xmax,h=this.ymax;break;case 10:t=8;continue;case 8:t=9,l=this.xmin,h=this.ymax;break;case 9:t=1;continue;case 1:t=5,l=this.xmin,h=this.ymin;break}(e[s]!==l||e[s+1]!==h)&&this.contains(i,l,h)&&(e.splice(s,0,l,h),s+=2)}return s}_project(i,t,n,e){let s=1/0,l,h,r;if(e<0){if(t<=this.ymin)return null;(l=(this.ymin-t)/e)<s&&(r=this.ymin,h=i+(s=l)*n)}else if(e>0){if(t>=this.ymax)return null;(l=(this.ymax-t)/e)<s&&(r=this.ymax,h=i+(s=l)*n)}if(n>0){if(i>=this.xmax)return null;(l=(this.xmax-i)/n)<s&&(h=this.xmax,r=t+(s=l)*e)}else if(n<0){if(i<=this.xmin)return null;(l=(this.xmin-i)/n)<s&&(h=this.xmin,r=t+(s=l)*e)}return[h,r]}_edgecode(i,t){return(i===this.xmin?1:i===this.xmax?2:0)|(t===this.ymin?4:t===this.ymax?8:0)}_regioncode(i,t){return(i<this.xmin?1:i>this.xmax?2:0)|(t<this.ymin?4:t>this.ymax?8:0)}_simplify(i){if(i&&i.length>4){for(let t=0;t<i.length;t+=2){const n=(t+2)%i.length,e=(t+4)%i.length;(i[t]===i[n]&&i[n]===i[e]||i[t+1]===i[n+1]&&i[n+1]===i[e+1])&&(i.splice(n,2),t-=2)}i.length||(i=null)}return i}}export{K as default};
