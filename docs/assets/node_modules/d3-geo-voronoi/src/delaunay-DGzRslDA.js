import{radians as q,sin as N,cos as v,sqrt as A,atan2 as D,degrees as x,asin as M,max as S,min as F,sign as y}from"./math-CNk5DYL8.js";import{cartesianDot as R,cartesianCross as g,cartesianAdd as E,cartesianNormalize as p}from"./cartesian-B33FdpeH.js";import C from"../../d3-geo/src/rotation-VxZSMODn.js";import I from"../../d3-geo/src/projection/stereographic-BIDZlFJA.js";import V from"../../d3-delaunay/src/delaunay-BOrpbDNw.js";import $ from"../../d3-array/src/extent-ColhFGRq.js";function b(e){return[D(e[1],e[0])*x,M(S(-1,F(1,e[2])))*x]}function d(e){const u=e[0]*q,r=e[1]*q,n=v(r);return[n*v(u),n*N(u),N(r)]}function k(e){return e=e.map(u=>d(u)),R(e[0],g(e[2],e[1]))}function ne(e){const u=G(e),r=J(u),n=H(r,e),o=L(r,e.length),a=B(o,e),s=K(r,e),{polygons:t,centers:f}=O(s,r,e),l=P(t),h=T(r,e),c=Q(n,r);return{delaunay:u,edges:n,triangles:r,centers:f,neighbors:o,polygons:t,mesh:l,hull:h,urquhart:c,find:a}}function B(e,u){function r(n,o){let a=n[0]-o[0],s=n[1]-o[1],t=n[2]-o[2];return a*a+s*s+t*t}return function(o,a,s){s===void 0&&(s=0);let t,f,l=s;const h=d([o,a]);do t=s,s=null,f=r(h,d(u[t])),e[t].forEach(c=>{let i=r(h,d(u[c]));if(i<f){f=i,s=c,l=c;return}});while(s!==null);return l}}function G(e){if(e.length<2)return{};let u=0;for(;isNaN(e[u][0]+e[u][1])&&u++<e.length;);const r=C(e[u]),n=I().translate([0,0]).scale(1).rotate(r.invert([180,0]));e=e.map(n);const o=[];let a=1;for(let c=0,i=e.length;c<i;c++){let m=e[c][0]**2+e[c][1]**2;!isFinite(m)||m>1e32?o.push(c):m>a&&(a=m)}const s=1e6*A(a);o.forEach(c=>e[c]=[s,0]),e.push([0,s]),e.push([-s,0]),e.push([0,-s]);const t=V.from(e);t.projection=n;const{triangles:f,halfedges:l,inedges:h}=t;for(let c=0,i=l.length;c<i;c++)if(l[c]<0){const m=c%3==2?c-2:c+1,w=c%3==0?c+2:c-1,_=l[m],j=l[w];l[_]=j,l[j]=_,l[m]=l[w]=-1,f[c]=f[m]=f[w]=u,h[f[_]]=_%3==0?_+2:_-1,h[f[j]]=j%3==0?j+2:j-1,c+=2-c%3}else f[c]>e.length-3-1&&(f[c]=u);return t}function H(e,u){const r=new Set;return u.length===2?[[0,1]]:(e.forEach(n=>{if(n[0]!==n[1]&&!(k(n.map(o=>u[o]))<0))for(let o=0,a;o<3;o++)a=(o+1)%3,r.add($([n[o],n[a]]).join("-"))}),Array.from(r,n=>n.split("-").map(Number)))}function J(e){const{triangles:u}=e;if(!u)return[];const r=[];for(let n=0,o=u.length/3;n<o;n++){const a=u[3*n],s=u[3*n+1],t=u[3*n+2];a!==s&&s!==t&&r.push([a,t,s])}return r}function K(e,u){return e.map(r=>{const n=r.map(a=>u[a]).map(d),o=E(E(g(n[1],n[0]),g(n[2],n[1])),g(n[0],n[2]));return b(p(o))})}function L(e,u){const r=[];return e.forEach(n=>{for(let o=0;o<3;o++){const a=n[o],s=n[(o+1)%3];r[a]=r[a]||[],r[a].push(s)}}),e.length===0&&(u===2?(r[0]=[1],r[1]=[0]):u===1&&(r[0]=[])),r}function O(e,u,r){const n=[],o=e.slice();if(u.length===0){if(r.length<2)return{polygons:n,centers:o};if(r.length===2){const t=d(r[0]),f=d(r[1]),l=p(E(t,f)),h=p(g(t,f)),c=g(l,h),i=[l,g(l,c),g(g(l,c),c),g(g(g(l,c),c),c)].map(b).map(s);return n.push(i),n.push(i.slice().reverse()),{polygons:n,centers:o}}}u.forEach((t,f)=>{for(let l=0;l<3;l++){const h=t[l],c=t[(l+1)%3],i=t[(l+2)%3];n[h]=n[h]||[],n[h].push([c,i,f,[h,c,i]])}});const a=n.map(t=>{const f=[t[0][2]];let l=t[0][1];for(let h=1;h<t.length;h++)for(let c=0;c<t.length;c++)if(t[c][0]==l){l=t[c][1],f.push(t[c][2]);break}if(f.length>2)return f;if(f.length==2){const h=z(r[t[0][3][0]],r[t[0][3][1]],o[f[0]]),c=z(r[t[0][3][2]],r[t[0][3][0]],o[f[0]]),i=s(h),m=s(c);return[f[0],m,f[1],i]}});function s(t){let f=-1;return o.slice(u.length,1/0).forEach((l,h)=>{l[0]===t[0]&&l[1]===t[1]&&(f=h+u.length)}),f<0&&(f=o.length,o.push(t)),f}return{polygons:a,centers:o}}function z(e,u,r){e=d(e),u=d(u),r=d(r);const n=y(R(g(u,e),r));return b(p(E(e,u)).map(o=>n*o))}function P(e){const u=[];return e.forEach(r=>{if(!r)return;let n=r[r.length-1];for(let o of r)o>n&&u.push([n,o]),n=o}),u}function Q(e,u){return function(r){const n=new Map,o=new Map;return e.forEach((a,s)=>{const t=a.join("-");n.set(t,r[s]),o.set(t,!0)}),u.forEach(a=>{let s=0,t=-1;for(let f=0;f<3;f++){let l=$([a[f],a[(f+1)%3]]).join("-");n.get(l)>s&&(s=n.get(l),t=l)}o.set(t,!1)}),e.map(a=>o.get(a.join("-")))}}function T(e,u){const r=new Set,n=[];e.map(t=>{if(!(k(t.map(f=>u[f>u.length?0:f]))>1e-12))for(let f=0;f<3;f++){let l=[t[f],t[(f+1)%3]],h=`${l[0]}-${l[1]}`;r.has(h)?r.delete(h):r.add(`${l[1]}-${l[0]}`)}});const o=new Map;let a;if(r.forEach(t=>{t=t.split("-").map(Number),o.set(t[0],t[1]),a=t[0]}),a===void 0)return n;let s=a;do{n.push(s);let t=o.get(s);o.set(s,-1),s=t}while(s>-1&&s!==a);return n}export{k as excess,ne as geoDelaunay};
